
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>biotuner.harmonic_connectivity &#8212; Biotuner 0.0.1 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/example_gallery_styles.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/thebelab-helper.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Biotuner 0.0.1 documentation</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Menu:
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../getting_started.html">
   Getting started with Biotuner
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../cite_us.html">
   Cite us
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../examples/index.html">
   Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/biotuner_MNE/biotuner_MNE.html">
     Harmonicity Metrics Computation on MNE Epochs File
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/peaks_extraction/peaks_extraction.html">
     Peaks extraction methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/harmonicity_metrics/harmonicity_metrics.html">
     Harmonicity metrics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/harmonic_spectrum/harmonic_spectrum.html">
     From Spectral Peaks to Harmonic Spectrum Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/scale_construction/scale_construction.html">
     Constructing musical tunings with biosignals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/spectral_chords/spectral_chords.html">
     Deriving spectral chords from biosignals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/rhythm_construction/rhythm_construction.html">
     Constructing euclidian rhythms from biotunings
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../examples/phase_amplitude_coupling/phase_amplitude_coupling.html">
     Phase-Amplitude Coupling
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../api/index.html">
   API
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/biotuner_object.html">
     Biotuner object
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/metrics.html">
     Harmonicity Metrics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/harmonic_spectrum.html">
     Harmonic spectrum
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/harmonic_connectivity.html">
     Harmonic connectivity
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/peaks_extension.html">
     Peaks Extension
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/peaks_extraction.html">
     Peaks Extraction
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/rhythm_construction.html">
     Rhythm construction
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
    <label for="toctree-checkbox-9">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/scale_construction.html">
     Scale construction
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
    <label for="toctree-checkbox-10">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../api/utils.html">
     Biotuner utilities
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
    <label for="toctree-checkbox-11">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1></h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <h1>Source code for biotuner.harmonic_connectivity</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">biotuner.biotuner_object</span> <span class="kn">import</span> <span class="n">compute_biotuner</span>
<span class="kn">from</span> <span class="nn">biotuner.metrics</span> <span class="kn">import</span> <span class="n">ratios2harmsim</span><span class="p">,</span> <span class="n">compute_subharmonics_2lists</span><span class="p">,</span> <span class="n">euler</span>
<span class="kn">from</span> <span class="nn">biotuner.biotuner_utils</span> <span class="kn">import</span> <span class="n">rebound_list</span><span class="p">,</span> <span class="n">butter_bandpass_filter</span>
<span class="kn">from</span> <span class="nn">biotuner.peaks_extension</span> <span class="kn">import</span> <span class="n">harmonic_fit</span>
<span class="kn">from</span> <span class="nn">biotuner.transitional_harmony</span> <span class="kn">import</span> <span class="n">transitional_harmony</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sbn</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mutual_info_score</span>
<span class="kn">import</span> <span class="nn">pywt</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">from</span> <span class="nn">mne.viz</span> <span class="kn">import</span> <span class="n">circular_layout</span>
<span class="kn">from</span> <span class="nn">mne_connectivity.viz</span> <span class="kn">import</span> <span class="n">plot_connectivity_circle</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">PyEMD</span> <span class="kn">import</span> <span class="n">EMD</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="kn">from</span> <span class="nn">biotuner.metrics</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dyad_similarity</span><span class="p">,</span>
    <span class="n">compute_subharmonic_tension</span><span class="p">,</span>
    <span class="n">ratios2harmsim</span><span class="p">,</span>
    <span class="n">peaks_to_harmsim</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">biotuner.harmonic_spectrum</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_frequency_and_psd</span><span class="p">,</span>
    <span class="n">compute_resonance_values</span><span class="p">,</span>
    <span class="n">find_spectral_peaks</span><span class="p">,</span>
    <span class="n">harmonic_entropy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">biotuner.biotuner_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">safe_mean</span><span class="p">,</span>
    <span class="n">safe_max</span><span class="p">,</span>
    <span class="n">apply_power_law_remove</span><span class="p">,</span>
    <span class="n">compute_frequency_and_psd</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">stft</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span><span class="p">,</span> <span class="n">gaussian_filter1d</span>
<span class="kn">from</span> <span class="nn">PyEMD</span> <span class="kn">import</span> <span class="n">EMD</span> <span class="k">as</span> <span class="n">EMD_eeg</span>
<span class="kn">import</span> <span class="nn">emd</span>
<span class="kn">from</span> <span class="nn">biotuner.peaks_extraction</span> <span class="kn">import</span> <span class="n">EMD_eeg</span>


<div class="viewcode-block" id="harmonic_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity">[docs]</a><span class="k">class</span> <span class="nc">harmonic_connectivity</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to compute harmonicity metrics</span>
<span class="sd">    between pairs of sensors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">peaks_function</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">n_harm</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
        <span class="n">min_freq</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sf: int</span>
<span class="sd">            sampling frequency (in Hz)</span>
<span class="sd">        data : 2Darray(elec, numDataPoints)</span>
<span class="sd">            Electrodes x Time series to analyse.</span>
<span class="sd">        peaks_function: str</span>
<span class="sd">            Defaults to &#39;EMD&#39;.</span>
<span class="sd">            See compute_biotuner class for details.</span>
<span class="sd">        precision: float</span>
<span class="sd">            Defaults to 0.1</span>
<span class="sd">            precision of the peaks (in Hz)</span>
<span class="sd">            When HH1D_max is used, bins are in log scale.</span>
<span class="sd">        n_harm: int</span>
<span class="sd">            Defaults to 10.</span>
<span class="sd">            Set the number of harmonics to compute in harmonic_fit function</span>
<span class="sd">        harm_function: str</span>
<span class="sd">            {&#39;mult&#39; or &#39;div&#39;}</span>
<span class="sd">            Defaults to &#39;mult&#39;</span>
<span class="sd">            Computes harmonics from iterative multiplication (x, 2x, 3x, ...nx)</span>
<span class="sd">            or division (x, x/2, x/3, ...x/n).</span>
<span class="sd">        min_freq: float, optional</span>
<span class="sd">            Defaults = 2. Minimum frequency (in Hz) to consider for peak extraction.</span>
<span class="sd">        max_freq: float, optional</span>
<span class="sd">            Defaults = 80. Maximum frequency (in Hz) to consider for peak extraction.</span>
<span class="sd">        n_peaks: int, optional</span>
<span class="sd">            Default = 5. Number of peaks to extract per frequency band.</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializing data&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sf</span> <span class="o">=</span> <span class="n">sf</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializing arguments for peak extraction&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span> <span class="o">=</span> <span class="n">peaks_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span> <span class="o">=</span> <span class="n">n_harm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harm_function</span> <span class="o">=</span> <span class="n">harm_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span> <span class="o">=</span> <span class="n">min_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span> <span class="o">=</span> <span class="n">max_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span> <span class="o">=</span> <span class="n">n_peaks</span>

<div class="viewcode-block" id="harmonic_connectivity.compute_harm_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_harm_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_harm_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">savename</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the harmonic connectivity matrix between electrodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        metric : str, optional</span>
<span class="sd">            The metric to use for computing harmonic connectivity. Default is &#39;harmsim&#39;.</span>
<span class="sd">            Possible values are:</span>

<span class="sd">            * &#39;harmsim&#39;: computes the harmonic similarity between each pair of peaks from the two electrodes.</span>
<span class="sd">            It calculates the ratio between each pair of peaks and computes the mean harmonic similarity.</span>

<span class="sd">            * &#39;euler&#39;: computes the Euler&#39;s totient function on the concatenated peaks of the two electrodes.</span>
<span class="sd">            It provides a measure of the number of positive integers that are relatively prime to the concatenated peaks.</span>

<span class="sd">            * &#39;harm_fit&#39;: computes the number of common harmonics between each pair of peaks from the two electrodes.</span>
<span class="sd">            It evaluates the harmonic fit between each peak pair and counts the number of common harmonics.</span>

<span class="sd">            * &#39;subharm_tension&#39;: computes the tension between subharmonics of two electrodes.</span>
<span class="sd">            It evaluates the tension between subharmonics of the two electrodes by comparing the subharmonics and their ratios.</span>

<span class="sd">            * &#39;RRCi&#39;: computes the Rhythmic Ratio Coupling with Imaginary Component (RRCi) metric between each pair of</span>
<span class="sd">            peaks from the two electrodes, using a bandwidth of 2 Hz and a max_denom of 16. This metric calculates the</span>
<span class="sd">            imaginary part of the complex phase differences between two filtered signals, accounting for volume conduction.</span>
<span class="sd">            A higher absolute value of the imaginary part indicates stronger phase coupling while being less sensitive</span>
<span class="sd">            to volume conduction.</span>

<span class="sd">            * &#39;wPLI_crossfreq&#39;: computes the weighted Phase Lag Index (wPLI) for cross-frequency coupling between each pair</span>
<span class="sd">            of peaks from the two electrodes. The wPLI measures the phase synchronization between two signals, with a value</span>
<span class="sd">            close to 0 indicating no synchronization and a value close to 1 indicating perfect synchronization.</span>

<span class="sd">            * &#39;wPLI_multiband&#39;: computes the weighted Phase Lag Index (wPLI) for multiple frequency bands between the two electrodes.</span>
<span class="sd">            It calculates wPLI for each frequency band and returns an array of wPLI values for the defined frequency bands.</span>

<span class="sd">            * &#39;MI&#39;: computes the Mutual Information (MI) between the instantaneous phases of each pair of peaks from the two electrodes.</span>
<span class="sd">            MI is a measure of the dependence between the two signals, with a higher value indicating a stronger relationship.</span>

<span class="sd">            * &#39;MI_spectral&#39;: computes the spectral Mutual Information (MI) between the two electrodes for each pair of peaks.</span>
<span class="sd">            It evaluates the MI for the concatenated peaks and returns the average MI value for the pairs of peaks.</span>

<span class="sd">        delta_lim : int, optional</span>
<span class="sd">            The delta limit for the subharmonic tension metric. Default is 20.</span>

<span class="sd">        save : bool, optional</span>
<span class="sd">            Whether to save the connectivity matrix. Default is False.</span>

<span class="sd">        savename : str, optional</span>
<span class="sd">            The name to use when saving the connectivity matrix. Default is &#39;_&#39;.</span>

<span class="sd">        graph : bool, optional</span>
<span class="sd">            Whether to display a heatmap of the connectivity matrix. Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conn_matrix : numpy.ndarray</span>
<span class="sd">            The harmonic connectivity matrix between electrodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize biotuner object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">list_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list_idx</span><span class="p">,</span> <span class="n">list_idx</span><span class="p">))</span>
        <span class="n">harm_conn_matrix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">FREQ_BANDS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">FREQ_BANDS</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.55</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">3.55</span><span class="p">,</span> <span class="mf">7.15</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">7.15</span><span class="p">,</span> <span class="mf">14.3</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">14.3</span><span class="p">,</span> <span class="mf">28.55</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">28.55</span><span class="p">,</span> <span class="mf">49.4</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_multiband&quot;</span><span class="p">:</span>
            <span class="n">harm_conn_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">FREQ_BANDS</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># if i % (len(pairs) // 10) == 0:</span>
            <span class="n">percentage_complete</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">percentage_complete</span><span class="si">}</span><span class="s2">% complete&quot;</span><span class="p">)</span>
            <span class="n">bt1</span> <span class="o">=</span> <span class="n">compute_biotuner</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bt1</span><span class="o">.</span><span class="n">peaks_extraction</span><span class="p">(</span>
                <span class="n">data1</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">max_harm_freq</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">list1</span> <span class="o">=</span> <span class="n">bt1</span><span class="o">.</span><span class="n">peaks</span>
            <span class="n">bt2</span> <span class="o">=</span> <span class="n">compute_biotuner</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bt2</span><span class="o">.</span><span class="n">peaks_extraction</span><span class="p">(</span>
                <span class="n">data2</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">max_harm_freq</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nperseg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nfft</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">smooth_fft</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">FREQ_BANDS</span><span class="o">=</span><span class="n">FREQ_BANDS</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">list2</span> <span class="o">=</span> <span class="n">bt2</span><span class="o">.</span><span class="n">peaks</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                <span class="p">(</span>
                    <span class="n">common_subs</span><span class="p">,</span>
                    <span class="n">delta_t</span><span class="p">,</span>
                    <span class="n">sub_tension_final</span><span class="p">,</span>
                    <span class="n">harm_temp</span><span class="p">,</span>
                    <span class="n">pairs_melody</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">compute_subharmonics_2lists</span><span class="p">(</span>
                    <span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">2.1</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">sub_tension_final</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_tension_final</span><span class="p">)</span>
            <span class="c1"># compute the harmonic similarity between each pair of peaks from the two electrodes.</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                <span class="n">harm_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>
                <span class="n">ratios</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">harm_pairs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">ratios</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ratios</span> <span class="o">=</span> <span class="n">rebound_list</span><span class="p">(</span><span class="n">ratios</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratios2harmsim</span><span class="p">(</span><span class="n">ratios</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;RRCi&quot;</span><span class="p">:</span>
                <span class="n">rrci_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                        <span class="n">rrci_value</span> <span class="o">=</span> <span class="n">cross_frequency_rrci</span><span class="p">(</span>
                            <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">16</span>
                        <span class="p">)</span>
                        <span class="n">rrci_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rrci_value</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rrci_values</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;euler&quot;</span><span class="p">:</span>
                <span class="n">list_all</span> <span class="o">=</span> <span class="n">list1</span> <span class="o">+</span> <span class="n">list2</span>
                <span class="n">list_all</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_all</span><span class="p">]</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">euler</span><span class="p">(</span><span class="o">*</span><span class="n">list_all</span><span class="p">))</span>

            <span class="c1"># to do</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;if metric == &#39;PPC_bicor&#39;:</span>
<span class="sd">                list_all = list1 + list2</span>
<span class="sd">                list_all = [int(x*10) for x in list_all]</span>
<span class="sd">                harm_conn_matrix.append(euler(*list_all))&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;harm_fit&quot;</span><span class="p">:</span>
                <span class="n">harm_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>
                <span class="n">harm_fit</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">harm_pairs</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">harmonic_fit</span><span class="p">(</span>
                        <span class="n">p</span><span class="p">,</span>
                        <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
                        <span class="n">bounds</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                        <span class="n">function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
                        <span class="n">div_mode</span><span class="o">=</span><span class="s2">&quot;div&quot;</span><span class="p">,</span>
                        <span class="n">n_common_harms</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">harm_fit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">harm_fit</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_crossfreq&quot;</span><span class="p">:</span>
                <span class="n">wPLI_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                        <span class="n">wPLI_value</span> <span class="o">=</span> <span class="n">wPLI_crossfreq</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">)</span>
                        <span class="n">wPLI_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wPLI_value</span><span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wPLI_values</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_multiband&quot;</span><span class="p">:</span>
                <span class="n">wPLI_values</span> <span class="o">=</span> <span class="n">wPLI_multiband</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">FREQ_BANDS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wPLI_values</span><span class="p">):</span>
                    <span class="n">harm_conn_matrix</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;MI&quot;</span><span class="p">:</span>
                <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">MI_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">peak1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">peak2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                        <span class="c1"># Filter the original signals using the frequency bands</span>
                        <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
                            <span class="n">data1</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
                        <span class="p">)</span>
                        <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
                            <span class="n">data2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
                        <span class="p">)</span>

                        <span class="c1"># Compute the instantaneous phase of each signal using the Hilbert transform</span>
                        <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">))</span>
                        <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">))</span>
                        <span class="n">phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span>
                        <span class="n">phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>

                        <span class="c1"># Compute Mutual Information</span>
                        <span class="n">MI_value</span> <span class="o">=</span> <span class="n">compute_mutual_information</span><span class="p">(</span><span class="n">phase1</span><span class="p">,</span> <span class="n">phase2</span><span class="p">)</span>
                        <span class="n">MI_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MI_value</span><span class="p">)</span>

                        <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">MI_values</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;MI_spectral&quot;</span><span class="p">:</span>
                <span class="c1"># Create the pairs of peaks</span>
                <span class="n">peak_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span>

                <span class="c1"># Compute the average MI value for the pairs of peaks</span>
                <span class="n">avg_mi</span> <span class="o">=</span> <span class="n">MI_spectral</span><span class="p">(</span>
                    <span class="n">data1</span><span class="p">,</span>
                    <span class="n">data2</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                    <span class="n">peak_pairs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">harm_conn_matrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_mi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;wPLI_multiband&quot;</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">harm_conn_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">harm_conn_matrix</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="c1"># conn_matrix = matrix.astype(&#39;float&#39;)</span>
        <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sbn</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn_matrix</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="harmonic_connectivity.compute_time_resolved_harm_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_time_resolved_harm_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_time_resolved_harm_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="mi">50</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the time-resolved harmonic connectivity matrix between electrodes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Input data with shape (num_electrodes, numDataPoints)</span>
<span class="sd">        sf : int</span>
<span class="sd">            Sampling frequency</span>
<span class="sd">        nIMFs : int</span>
<span class="sd">            Number of intrinsic mode functions (IMFs) to consider.</span>
<span class="sd">        metric : str, optional</span>
<span class="sd">            The metric to use for computing harmonic connectivity. Default is &#39;harmsim&#39;.</span>
<span class="sd">        delta_lim : int, optional</span>
<span class="sd">            The delta limit for the subharmonic tension metric. Default is 20.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        connectivity_matrices : numpy.ndarray</span>
<span class="sd">            Time-resolved harmonic connectivity matrices with shape (IMFs, numDataPoints, electrodes, electrodes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">num_electrodes</span><span class="p">,</span> <span class="n">numDataPoints</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">connectivity_matrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">nIMFs</span><span class="p">,</span> <span class="n">numDataPoints</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">harmonicity_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIMFs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDataPoints</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">):</span>
                        <span class="n">pair_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">pair_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">harmonicity_cache</span><span class="p">:</span>
                            <span class="n">time_series1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="n">time_series2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                            <span class="n">harmonicity_cache</span><span class="p">[</span><span class="n">pair_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">EMD_time_resolved_harmonicity</span><span class="p">(</span>
                                <span class="n">time_series1</span><span class="p">,</span>
                                <span class="n">time_series2</span><span class="p">,</span>
                                <span class="n">sf</span><span class="p">,</span>
                                <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">,</span>
                                <span class="n">method</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                            <span class="p">)</span>

                        <span class="n">harmonicity</span> <span class="o">=</span> <span class="n">harmonicity_cache</span><span class="p">[</span><span class="n">pair_key</span><span class="p">]</span>
                        <span class="n">connectivity_matrices</span><span class="p">[</span><span class="n">imf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">harmonicity</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span>
                        <span class="n">connectivity_matrices</span><span class="p">[</span><span class="n">imf</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">harmonicity</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">connectivity_matrices</span></div>

    <span class="c1"># method for computing inter-electrodes correlations between transitional harmony matrices</span>
<div class="viewcode-block" id="harmonic_connectivity.transitional_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.transitional_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">transitional_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;win_overlap&quot;</span><span class="p">,</span>
        <span class="n">overlap</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_trans_harm</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transitional connectivity between electrodes using transitional harmony</span>
<span class="sd">        and temporal correlation with False Discovery Rate (FDR) correction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">            Multichannel EEG data with shape (n_electrodes, n_timepoints).</span>
<span class="sd">        sf : float</span>
<span class="sd">            Sampling frequency of the EEG data in Hz.</span>
<span class="sd">        mode : str, optional, default=&#39;win_overlap&#39;</span>
<span class="sd">            The mode to compute the transitional harmony. Default is &#39;win_overlap&#39;.</span>
<span class="sd">        overlap : int, optional, default=10</span>
<span class="sd">            The percentage of overlap between consecutive windows when computing</span>
<span class="sd">            the transitional harmony. Default is 10.</span>
<span class="sd">        delta_lim : int, optional, default=20</span>
<span class="sd">            The maximum allowed frequency change (delta frequency) between two</span>
<span class="sd">            consecutive peaks in Hz. Default is 20.</span>
<span class="sd">        graph : bool, optional, default=False</span>
<span class="sd">            If True, it will plot the graph of the transitional harmony. Default is False.</span>
<span class="sd">        n_trans_harm : int, optional, default=3</span>
<span class="sd">            Number of transitional harmonics to compute. Default is 3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        conn_mat : numpy.ndarray</span>
<span class="sd">            Connectivity matrix of shape (n_electrodes, n_electrodes) representing</span>
<span class="sd">            the transitional connectivity between electrodes.</span>
<span class="sd">        pval_mat : numpy.ndarray</span>
<span class="sd">            P-value matrix of shape (n_electrodes, n_electrodes) with FDR-corrected</span>
<span class="sd">            p-values for the computed connectivity values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function computes the transitional connectivity between electrodes by</span>
<span class="sd">        first calculating the transitional harmony for each electrode and then</span>
<span class="sd">        computing the temporal correlation between the transitional harmonies with</span>
<span class="sd">        FDR correction for multiple comparisons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">trans_subharm_tot</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_electrodes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_electrodes</span><span class="p">):</span>
            <span class="n">th</span> <span class="o">=</span> <span class="n">transitional_harmony</span><span class="p">(</span>
                <span class="n">sf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sf</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">elec</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">peaks_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">peaks_function</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">n_harm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_harm</span><span class="p">,</span>
                <span class="n">harm_function</span><span class="o">=</span><span class="s2">&quot;mult&quot;</span><span class="p">,</span>
                <span class="n">min_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_freq</span><span class="p">,</span>
                <span class="n">max_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_freq</span><span class="p">,</span>
                <span class="n">n_peaks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_peaks</span><span class="p">,</span>
                <span class="n">n_trans_harm</span><span class="o">=</span><span class="n">n_trans_harm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">trans_subharm</span><span class="p">,</span> <span class="n">time_vec_final</span><span class="p">,</span> <span class="n">pairs_melody</span> <span class="o">=</span> <span class="n">th</span><span class="o">.</span><span class="n">compute_trans_harmony</span><span class="p">(</span>
                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;win_overlap&quot;</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="n">graph</span>
            <span class="p">)</span>
            <span class="n">trans_subharm_tot</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trans_subharm</span><span class="p">)</span>
        <span class="n">subharm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trans_subharm_tot</span><span class="p">)</span>
        <span class="n">conn_mat</span><span class="p">,</span> <span class="n">pval_mat</span> <span class="o">=</span> <span class="n">temporal_correlation_fdr</span><span class="p">(</span><span class="n">subharm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn_mat</span><span class="p">,</span> <span class="n">pval_mat</span><span class="p">,</span> <span class="n">subharm</span></div>

<div class="viewcode-block" id="harmonic_connectivity.plot_conn_matrix"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.plot_conn_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">plot_conn_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conn_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">conn_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conn_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn_matrix</span>
        <span class="k">if</span> <span class="n">node_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_matrix</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_names</span><span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_connectivity_circle</span><span class="p">(</span>
            <span class="n">conn_matrix</span><span class="p">,</span>
            <span class="n">node_names</span><span class="o">=</span><span class="n">node_names</span><span class="p">,</span>
            <span class="n">n_lines</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
            <span class="n">fontsize_names</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
            <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="harmonic_connectivity.compute_harmonic_spectrum_connectivity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.compute_harmonic_spectrum_connectivity">[docs]</a>    <span class="k">def</span> <span class="nf">compute_harmonic_spectrum_connectivity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">power_law_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
        <span class="n">n_harms</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">delta_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">smoothness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">smoothness_harm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">phase_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">save_fig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">savename</span><span class="o">=</span><span class="s2">&quot;harmonic_spectrum_connectivity.png&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">sf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sf</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">electrodes</span><span class="p">,</span> <span class="n">datapoints</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Will store the generated DataFrames</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">electrodes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">electrodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">signal1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">signal2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">compute_cross_spectrum_harmonicity</span><span class="p">(</span>
                        <span class="n">signal1</span><span class="p">,</span>
                        <span class="n">signal2</span><span class="p">,</span>
                        <span class="n">precision_hz</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                        <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>
                        <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span>
                        <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                        <span class="n">fs</span><span class="o">=</span><span class="n">sf</span><span class="p">,</span>
                        <span class="n">power_law_remove</span><span class="o">=</span><span class="n">power_law_remove</span><span class="p">,</span>
                        <span class="n">n_peaks</span><span class="o">=</span><span class="n">n_peaks</span><span class="p">,</span>
                        <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                        <span class="n">n_harms</span><span class="o">=</span><span class="n">n_harms</span><span class="p">,</span>
                        <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span>
                        <span class="n">min_notes</span><span class="o">=</span><span class="n">min_notes</span><span class="p">,</span>
                        <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span>
                        <span class="n">smoothness</span><span class="o">=</span><span class="n">smoothness</span><span class="p">,</span>
                        <span class="n">smoothness_harm</span><span class="o">=</span><span class="n">smoothness_harm</span><span class="p">,</span>
                        <span class="n">phase_mode</span><span class="o">=</span><span class="n">phase_mode</span><span class="p">,</span>
                        <span class="n">save_fig</span><span class="o">=</span><span class="n">save_fig</span><span class="p">,</span>
                        <span class="n">save_name</span><span class="o">=</span><span class="n">savename</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;elec1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>  <span class="c1"># Add electrode indices to DataFrame</span>
                    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;elec2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">dfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Concatenate all the dataframes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span> <span class="o">=</span> <span class="n">output</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="harmonic_connectivity.get_harm_spectrum_metric_matrix"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.harmonic_connectivity.get_harm_spectrum_metric_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_harm_spectrum_metric_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="c1"># Check if self.harmonic_spectrum_connectivity exists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: No harmonic_spectrum_connectivity found.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Check if the metric exists in the DataFrame</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2"> not found in harmonic_spectrum_connectivity.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Create a pivot table with &#39;elec1&#39; and &#39;elec2&#39; as indices and &#39;metric&#39; as values</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">harmonic_spectrum_connectivity</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="s2">&quot;elec1&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="s2">&quot;elec2&quot;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">metric</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">matrix</span></div></div>


<div class="viewcode-block" id="wPLI_crossfreq"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.wPLI_crossfreq">[docs]</a><span class="k">def</span> <span class="nf">wPLI_crossfreq</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">peak1</span><span class="p">,</span> <span class="n">peak2</span><span class="p">,</span> <span class="n">sf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the weighted phase lag index (wPLI) between two signals in specified frequency bands, centered around</span>
<span class="sd">    provided peak frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    peak1 : float</span>
<span class="sd">        Center of the frequency band for the first signal.</span>
<span class="sd">    peak2 : float</span>
<span class="sd">        Center of the frequency band for the second signal.</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wPLI : float</span>
<span class="sd">        Weighted phase lag index between two signals in specified frequency bands.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; signal1 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; signal2 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; peak1 = 10.0</span>
<span class="sd">    &gt;&gt;&gt; peak2 = 20.0</span>
<span class="sd">    &gt;&gt;&gt; sf = 100.0</span>
<span class="sd">    &gt;&gt;&gt; wPLI = wPLI_crossfreq(signal1, signal2, peak1, peak2, sf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define a band around each peak</span>
    <span class="n">bandwidth</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># You can adjust the bandwidth as needed</span>

    <span class="c1"># Filter the original signals using the frequency bands</span>
    <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak1</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sf</span>
    <span class="p">)</span>
    <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span>
        <span class="n">signal2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">peak2</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sf</span>
    <span class="p">)</span>

    <span class="c1"># Compute the wPLI between the filtered signals</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">)</span>
    <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">))</span>
    <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">))</span>

    <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>
    <span class="n">wPLI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">wPLI</span></div>


<div class="viewcode-block" id="wPLI_multiband"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.wPLI_multiband">[docs]</a><span class="k">def</span> <span class="nf">wPLI_multiband</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">freq_bands</span><span class="p">,</span> <span class="n">sf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the weighted phase lag index (wPLI) between two signals for multiple frequency bands.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    freq_bands : list of tuple</span>
<span class="sd">        List of frequency bands. Each band is represented as a tuple (lowcut, highcut).</span>
<span class="sd">    sf : float</span>
<span class="sd">        Sampling frequency.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wPLI_values : list of float</span>
<span class="sd">        List of wPLI values for each frequency band.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; signal1 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; signal2 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; freq_bands = [(8, 12), (13, 30), (30, 70)]</span>
<span class="sd">    &gt;&gt;&gt; sf = 100.0</span>
<span class="sd">    &gt;&gt;&gt; wPLI_values = wPLI_multiband(signal1, signal2, freq_bands, sf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wPLI_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">freq_bands</span><span class="p">:</span>
        <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span> <span class="o">=</span> <span class="n">band</span>

        <span class="c1"># Filter the original signals using the frequency bands</span>
        <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>
        <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">butter_bandpass_filter</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">,</span> <span class="n">sf</span><span class="p">)</span>

        <span class="c1"># Compute the wPLI between the filtered signals</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">)</span>
        <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">))</span>
        <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">zscore</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">))</span>

        <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>
        <span class="n">wPLI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">wPLI</span><span class="p">)</span>
        <span class="n">wPLI_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wPLI</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wPLI_values</span></div>


<div class="viewcode-block" id="compute_mutual_information"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.compute_mutual_information">[docs]</a><span class="k">def</span> <span class="nf">compute_mutual_information</span><span class="p">(</span><span class="n">phase1</span><span class="p">,</span> <span class="n">phase2</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Discretize phase values into bins</span>
    <span class="n">discretized_phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span>
        <span class="n">phase1</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">discretized_phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span>
        <span class="n">phase2</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Compute the joint probability distribution of the discretized phase values</span>
    <span class="n">joint_prob</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
        <span class="n">discretized_phase1</span><span class="p">,</span> <span class="n">discretized_phase2</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">num_bins</span>
    <span class="p">)</span>

    <span class="c1"># Normalize the joint probability distribution</span>
    <span class="n">joint_prob</span> <span class="o">=</span> <span class="n">joint_prob</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">joint_prob</span><span class="p">)</span>

    <span class="c1"># Compute Mutual Information</span>
    <span class="n">MI</span> <span class="o">=</span> <span class="n">mutual_info_score</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">contingency</span><span class="o">=</span><span class="n">joint_prob</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">MI</span></div>


<div class="viewcode-block" id="MI_spectral"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.MI_spectral">[docs]</a><span class="k">def</span> <span class="nf">MI_spectral</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">peak_pairs</span><span class="p">,</span> <span class="n">wavelet</span><span class="o">=</span><span class="s2">&quot;cmor&quot;</span>
<span class="p">):</span>
    <span class="c1"># Define the scales for the CWT based on the desired frequency precision</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span> <span class="o">+</span> <span class="n">precision</span><span class="p">,</span> <span class="n">precision</span><span class="p">)</span>
    <span class="n">scales</span> <span class="o">=</span> <span class="p">(</span><span class="n">sf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">precision</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scales</span><span class="p">)</span>

    <span class="c1"># Compute the Continuous Wavelet Transform of the signals</span>
    <span class="n">cwt_signal1</span> <span class="o">=</span> <span class="n">pywt</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">wavelet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">cwt_signal2</span> <span class="o">=</span> <span class="n">pywt</span><span class="o">.</span><span class="n">cwt</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">scales</span><span class="p">,</span> <span class="n">wavelet</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Extract the phase values from the CWT coefficients</span>
    <span class="n">phase_signal1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cwt_signal1</span><span class="p">)</span>
    <span class="n">phase_signal2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cwt_signal2</span><span class="p">)</span>

    <span class="c1"># Compute the Mutual Information between the phase values in the time-frequency domain</span>
    <span class="n">mi_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">)):</span>
            <span class="n">mi_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mutual_info_score</span><span class="p">(</span>
                <span class="n">phase_signal1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">phase_signal2</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>

    <span class="c1"># Extract the MI values corresponding to the pairs of peaks</span>
    <span class="n">mi_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">peak_pairs</span><span class="p">:</span>
        <span class="n">scale1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">sf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">precision</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">scale2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">sf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">precision</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">mi_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mi_matrix</span><span class="p">[</span><span class="n">scale1</span><span class="p">,</span> <span class="n">scale2</span><span class="p">])</span>

    <span class="c1"># Calculate the average MI value for the pairs of peaks</span>
    <span class="n">avg_mi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mi_values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">avg_mi</span></div>


<div class="viewcode-block" id="cross_frequency_rrci"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.cross_frequency_rrci">[docs]</a><span class="k">def</span> <span class="nf">cross_frequency_rrci</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">freq_peak1</span><span class="p">,</span> <span class="n">freq_peak2</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_denom</span><span class="o">=</span><span class="mi">50</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Rhythmic Ratio Coupling Index (RRCI) between two signals for cross-frequency.</span>

<span class="sd">    The function first calculates the rhythmic ratio between two peak frequencies. It then filters</span>
<span class="sd">    the two input signals around a frequency band centered on their respective peak frequencies.</span>
<span class="sd">    Finally, it calculates the rhythmic ratio coupling index (RRCI) for these filtered signals.</span>
<span class="sd">    The RRCI is a measure of how much the rhythms of the two signals, in terms of their phase information,</span>
<span class="sd">    are coupled across different frequencies. In other words, it provides a measure of phase-to-phase</span>
<span class="sd">    coupling across these frequencies.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    sfreq : float</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    freq_peak1 : float</span>
<span class="sd">        Peak frequency for the first signal.</span>
<span class="sd">    freq_peak2 : float</span>
<span class="sd">        Peak frequency for the second signal.</span>
<span class="sd">    bandwidth : float, default=1</span>
<span class="sd">        Frequency bandwidth for filtering the signals.</span>
<span class="sd">    max_denom : int, default=50</span>
<span class="sd">        The maximum denominator for the rhythmic ratio.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rrci : float</span>
<span class="sd">        Rhythmic Ratio Coupling Index between the two signals.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; signal1 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; signal2 = np.random.normal(0, 1, 5000)</span>
<span class="sd">    &gt;&gt;&gt; sfreq = 100.0</span>
<span class="sd">    &gt;&gt;&gt; rrci = cross_frequency_rrci(signal1, signal2, sfreq, 10, 20, 2, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freq_band1</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_peak1</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">freq_peak1</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">freq_band2</span> <span class="o">=</span> <span class="p">(</span><span class="n">freq_peak2</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">freq_peak2</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">rhythmic_ratio</span> <span class="o">=</span> <span class="n">compute_rhythmic_ratio</span><span class="p">(</span><span class="n">freq_peak1</span><span class="p">,</span> <span class="n">freq_peak2</span><span class="p">,</span> <span class="n">max_denom</span><span class="p">)</span>

    <span class="n">rrci</span> <span class="o">=</span> <span class="n">rhythmic_ratio_coupling_imaginary</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">rhythmic_ratio</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">freq_band1</span><span class="p">,</span> <span class="n">freq_band2</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">rrci</span></div>


<div class="viewcode-block" id="compute_rhythmic_ratio"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.compute_rhythmic_ratio">[docs]</a><span class="k">def</span> <span class="nf">compute_rhythmic_ratio</span><span class="p">(</span><span class="n">freq1</span><span class="p">,</span> <span class="n">freq2</span><span class="p">,</span> <span class="n">max_denom</span><span class="p">):</span>
    <span class="n">ratio</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">freq1</span> <span class="o">/</span> <span class="n">freq2</span><span class="p">)</span><span class="o">.</span><span class="n">limit_denominator</span><span class="p">(</span><span class="n">max_denom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ratio</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">ratio</span><span class="o">.</span><span class="n">denominator</span></div>


<div class="viewcode-block" id="rhythmic_ratio_coupling_imaginary"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.rhythmic_ratio_coupling_imaginary">[docs]</a><span class="k">def</span> <span class="nf">rhythmic_ratio_coupling_imaginary</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span> <span class="n">signal2</span><span class="p">,</span> <span class="n">rhythmic_ratio</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">freq_band1</span><span class="p">,</span> <span class="n">freq_band2</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the Imaginary part of Rhythmic Ratio Coupling between two signals.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal1 : ndarray</span>
<span class="sd">        First signal in time series.</span>
<span class="sd">    signal2 : ndarray</span>
<span class="sd">        Second signal in time series.</span>
<span class="sd">    rhythmic_ratio : tuple</span>
<span class="sd">        Rhythmic ratio (numerator, denominator).</span>
<span class="sd">    sfreq : float</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    freq_band1 : tuple</span>
<span class="sd">        Frequency band for the first signal (lowcut, highcut).</span>
<span class="sd">    freq_band2 : tuple</span>
<span class="sd">        Frequency band for the second signal (lowcut, highcut).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    imaginary_part : float</span>
<span class="sd">        Imaginary part of the Rhythmic Ratio Coupling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_freq1</span><span class="p">,</span> <span class="n">h_freq1</span> <span class="o">=</span> <span class="n">freq_band1</span>
    <span class="n">l_freq2</span><span class="p">,</span> <span class="n">h_freq2</span> <span class="o">=</span> <span class="n">freq_band2</span>

    <span class="c1"># Filter the signals</span>
    <span class="n">filtered_signal1</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">l_freq1</span><span class="p">,</span> <span class="n">h_freq1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fir&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">filtered_signal2</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
        <span class="n">signal2</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">l_freq2</span><span class="p">,</span> <span class="n">h_freq2</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fir&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="c1"># Compute the Hilbert transform</span>
    <span class="n">analytic_signal1</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">filtered_signal1</span><span class="p">)</span>
    <span class="n">analytic_signal2</span> <span class="o">=</span> <span class="n">hilbert</span><span class="p">(</span><span class="n">filtered_signal2</span><span class="p">)</span>

    <span class="c1"># Extract instantaneous phases</span>
    <span class="n">phase1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal1</span><span class="p">)</span>
    <span class="n">phase2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">analytic_signal2</span><span class="p">)</span>

    <span class="c1"># Calculate the complex phase differences</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">rhythmic_ratio</span>
    <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">phase1</span> <span class="o">-</span> <span class="n">m</span> <span class="o">*</span> <span class="n">phase2</span>

    <span class="c1"># Compute the mean of the complex exponential of the phase differences</span>
    <span class="n">mean_exp_phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">phase_diff</span><span class="p">))</span>

    <span class="c1"># Extract the imaginary part</span>
    <span class="n">imaginary_part</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mean_exp_phase_diff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">imaginary_part</span><span class="p">)</span></div>


<div class="viewcode-block" id="HilbertHuang1D_nopeaks"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.HilbertHuang1D_nopeaks">[docs]</a><span class="k">def</span> <span class="nf">HilbertHuang1D_nopeaks</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">sf</span><span class="p">,</span>
    <span class="n">graph</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">min_freq</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">max_freq</span><span class="o">=</span><span class="mi">45</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">bin_spread</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">,</span>
    <span class="n">smooth_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Hilbert-Huang transform provides a description of how the energy</span>
<span class="sd">    or power within a signal is distributed across frequency.</span>
<span class="sd">    The distributions are based on the instantaneous frequency and</span>
<span class="sd">    amplitude of a signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array (numDataPoints,)</span>
<span class="sd">        Single time series.</span>
<span class="sd">    sf : int</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    graph : bool, default=False</span>
<span class="sd">        Defines if a graph is generated.</span>
<span class="sd">    nIMFs : int, default=5</span>
<span class="sd">        Number of intrinsic mode functions (IMFs) to keep when</span>
<span class="sd">        Empirical Mode Decomposition (EMD) is computed.</span>
<span class="sd">    min_freq : float, default=1</span>
<span class="sd">        Minimum frequency to consider.</span>
<span class="sd">    max_freq : float, default=80</span>
<span class="sd">        Maximum frequency to consider.</span>
<span class="sd">    precision : float, default=0.1</span>
<span class="sd">        Value in Hertz corresponding to the minimal step between two</span>
<span class="sd">        frequency bins.</span>
<span class="sd">    bin_spread : str, default=&#39;log&#39;</span>

<span class="sd">        - &#39;linear&#39;</span>
<span class="sd">        - &#39;log&#39;</span>
<span class="sd">    smooth_sigma : float, default=None</span>
<span class="sd">        Sigma value for gaussian smoothing.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    IF : array (numDataPoints,nIMFs)</span>
<span class="sd">        instantaneous frequencies associated with each IMF.</span>
<span class="sd">    IP : array (numDataPoints,nIMFs)</span>
<span class="sd">        instantaneous power associated with each IMF.</span>
<span class="sd">    IA : array (numDataPoints,nIMFs)</span>
<span class="sd">        instantaneous amplitude associated with each IMF.</span>
<span class="sd">    spec : array (nIMFs, nbins)</span>
<span class="sd">        Power associated with all bins for each IMF</span>
<span class="sd">    bins : array (nIMFs, nbins)</span>
<span class="sd">        Frequency bins for each IMF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">IMFs</span> <span class="o">=</span> <span class="n">EMD_eeg</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;EMD&quot;</span><span class="p">)</span>
    <span class="n">IMFs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">IMFs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">IP</span><span class="p">,</span> <span class="n">IF</span><span class="p">,</span> <span class="n">IA</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">frequency_transform</span><span class="p">(</span><span class="n">IMFs</span><span class="p">[:,</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">nIMFs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sf</span><span class="p">,</span> <span class="s2">&quot;nht&quot;</span><span class="p">)</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">min_freq</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">max_freq</span>
    <span class="n">range_hh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span>
    <span class="n">steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">range_hh</span> <span class="o">/</span> <span class="n">precision</span><span class="p">)</span>
    <span class="n">bin_size</span> <span class="o">=</span> <span class="n">range_hh</span> <span class="o">/</span> <span class="n">steps</span>
    <span class="n">edges</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">define_hist_bins</span><span class="p">(</span>
        <span class="n">low</span> <span class="o">-</span> <span class="p">(</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">high</span> <span class="o">-</span> <span class="p">(</span><span class="n">bin_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">steps</span><span class="p">,</span> <span class="n">bin_spread</span>
    <span class="p">)</span>
    <span class="c1"># Compute the 1d Hilbert-Huang transform (power over carrier frequency)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">IMF</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IF</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">freqs_</span><span class="p">,</span> <span class="n">spec_</span> <span class="o">=</span> <span class="n">emd</span><span class="o">.</span><span class="n">spectra</span><span class="o">.</span><span class="n">hilberthuang</span><span class="p">(</span><span class="n">IF</span><span class="p">[:,</span> <span class="n">IMF</span><span class="p">],</span> <span class="n">IA</span><span class="p">[:,</span> <span class="n">IMF</span><span class="p">],</span> <span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smooth_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spec_</span> <span class="o">=</span> <span class="n">gaussian_filter1d</span><span class="p">(</span><span class="n">spec_</span><span class="p">,</span> <span class="n">smooth_sigma</span><span class="p">)</span>
        <span class="n">freqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">freqs_</span><span class="p">)</span>
        <span class="n">spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spec_</span><span class="p">)</span>
    <span class="n">bins_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)):</span>
        <span class="n">bins_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">plot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bins_</span><span class="p">[</span><span class="n">plot</span><span class="p">],</span> <span class="n">spec</span><span class="p">[</span><span class="n">plot</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">min_freq</span><span class="p">,</span> <span class="n">max_freq</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;IA-weighted</span><span class="se">\n</span><span class="s2">Hilbert-Huang Transform&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;IMF-1&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-2&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-3&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-4&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-5&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-6&quot;</span><span class="p">,</span> <span class="s2">&quot;IMF-7&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">IF</span><span class="p">,</span> <span class="n">IP</span><span class="p">,</span> <span class="n">IA</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bins_</span><span class="p">)</span></div>


<div class="viewcode-block" id="EMD_time_resolved_harmonicity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.EMD_time_resolved_harmonicity">[docs]</a><span class="k">def</span> <span class="nf">EMD_time_resolved_harmonicity</span><span class="p">(</span>
    <span class="n">time_series1</span><span class="p">,</span> <span class="n">time_series2</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the harmonicity between the instantaneous frequencies (IF) for each</span>
<span class="sd">    point in time between all pairs of corresponding intrinsic mode functions (IMFs).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time_series1 : array (numDataPoints,)</span>
<span class="sd">        First time series.</span>
<span class="sd">    time_series2 : array (numDataPoints,)</span>
<span class="sd">        Second time series.</span>
<span class="sd">    sf : int</span>
<span class="sd">        Sampling frequency.</span>
<span class="sd">    nIMFs : int, default=5</span>
<span class="sd">        Number of intrinsic mode functions (IMFs) to consider.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    harmonicity : array (numDataPoints, nIMFs)</span>
<span class="sd">        Harmonicity values for each pair of corresponding IMFs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute the Hilbert-Huang transform for each time series</span>
    <span class="n">IF1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">HilbertHuang1D_nopeaks</span><span class="p">(</span><span class="n">time_series1</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">)</span>
    <span class="n">IF2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">HilbertHuang1D_nopeaks</span><span class="p">(</span><span class="n">time_series2</span><span class="p">,</span> <span class="n">sf</span><span class="p">,</span> <span class="n">nIMFs</span><span class="o">=</span><span class="n">nIMFs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">IF1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># Compute the harmonicity between the instantaneous frequencies of corresponding IMFs</span>
    <span class="n">harmonicity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">IF1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nIMFs</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">IF1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">imf</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIMFs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]:</span>
                        <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">/</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]:</span>
                        <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">/</span> <span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
                    <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subharm_tenion</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">IF1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">],</span> <span class="n">IF2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]],</span>
                    <span class="n">n_harmonics</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">delta_lim</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                    <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">subharm_tenion</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subharm_tenion</span> <span class="o">!=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">:</span>
                    <span class="n">harmonicity</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">imf</span><span class="p">]</span> <span class="o">=</span> <span class="n">subharm_tenion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">return</span> <span class="n">harmonicity</span></div>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">t</span>
<span class="kn">from</span> <span class="nn">statsmodels.stats.multitest</span> <span class="kn">import</span> <span class="n">multipletests</span>


<div class="viewcode-block" id="temporal_correlation_fdr"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.temporal_correlation_fdr">[docs]</a><span class="k">def</span> <span class="nf">temporal_correlation_fdr</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the temporal correlation for each pair of electrodes and output a connectivity matrix</span>
<span class="sd">    and a matrix of FDR-corrected p-values.</span>

<span class="sd">    Args:</span>
<span class="sd">    data (array): An array of shape (electrodes, samples) containing the electrode recordings.</span>

<span class="sd">    Returns:</span>
<span class="sd">    connectivity_matrix (array): A connectivity matrix of shape (electrodes, electrodes) with the temporal correlation for each pair of electrodes.</span>
<span class="sd">    fdr_corrected_pvals (array): A matrix of FDR-corrected p-values of shape (electrodes, electrodes).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">num_electrodes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">))</span>
    <span class="n">pvals_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_electrodes</span><span class="p">):</span>
            <span class="n">data_i_masked</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">data_j_masked</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

            <span class="n">corr</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">data_i_masked</span><span class="p">,</span> <span class="n">data_j_masked</span><span class="p">,</span> <span class="n">allow_masked</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">)</span>  <span class="c1"># Calculate number of non-NaN data points</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># Degrees of freedom</span>
            <span class="n">t_val</span> <span class="o">=</span> <span class="n">corr</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">df</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">corr</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Calculate t-value</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">t_val</span><span class="p">),</span> <span class="n">df</span><span class="p">))</span>  <span class="c1"># Calculate two-tailed p-value</span>

            <span class="n">connectivity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">pvals_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">corr</span><span class="p">,</span> <span class="n">pval</span>

    <span class="n">pvals</span> <span class="o">=</span> <span class="n">pvals_matrix</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">fdr_corrected_pvals</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">pvals</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fdr_bh&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fdr_corrected_pvals</span> <span class="o">=</span> <span class="n">fdr_corrected_pvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">num_electrodes</span><span class="p">,</span> <span class="n">num_electrodes</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">connectivity_matrix</span><span class="p">,</span> <span class="n">fdr_corrected_pvals</span></div>


<div class="viewcode-block" id="compute_cross_spectrum_harmonicity"><a class="viewcode-back" href="../../api/harmonic_connectivity.html#biotuner.harmonic_connectivity.compute_cross_spectrum_harmonicity">[docs]</a><span class="k">def</span> <span class="nf">compute_cross_spectrum_harmonicity</span><span class="p">(</span>
    <span class="n">signal1</span><span class="p">,</span>
    <span class="n">signal2</span><span class="p">,</span>
    <span class="n">precision_hz</span><span class="p">,</span>
    <span class="n">fmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">fmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">noverlap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">fs</span><span class="o">=</span><span class="mi">44100</span><span class="p">,</span>
    <span class="n">power_law_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">n_peaks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;harmsim&quot;</span><span class="p">,</span>
    <span class="n">n_harms</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">delta_lim</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
    <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">smoothness</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">smoothness_harm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">phase_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">save_fig</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">save_name</span><span class="o">=</span><span class="s2">&quot;harmonic_spectrum_connectivity.png&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">nperseg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">precision_hz</span><span class="p">)</span>

    <span class="c1"># Compute the power spectral density for both signals</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd1</span> <span class="o">=</span> <span class="n">compute_frequency_and_psd</span><span class="p">(</span>
        <span class="n">signal1</span><span class="p">,</span> <span class="n">precision_hz</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span>
    <span class="p">)</span>
    <span class="n">freqs</span><span class="p">,</span> <span class="n">psd2</span> <span class="o">=</span> <span class="n">compute_frequency_and_psd</span><span class="p">(</span>
        <span class="n">signal2</span><span class="p">,</span> <span class="n">precision_hz</span><span class="p">,</span> <span class="n">smoothness</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span>
    <span class="p">)</span>

    <span class="n">psd1_clean</span> <span class="o">=</span> <span class="n">apply_power_law_remove</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd1</span><span class="p">,</span> <span class="n">power_law_remove</span><span class="p">)</span>
    <span class="n">psd2_clean</span> <span class="o">=</span> <span class="n">apply_power_law_remove</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">psd2</span><span class="p">,</span> <span class="n">power_law_remove</span><span class="p">)</span>

    <span class="n">psd1_min</span><span class="p">,</span> <span class="n">psd1_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psd1_clean</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psd1_clean</span><span class="p">)</span>
    <span class="n">psd1_clean</span> <span class="o">=</span> <span class="p">(</span><span class="n">psd1_clean</span> <span class="o">-</span> <span class="n">psd1_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psd1_max</span> <span class="o">-</span> <span class="n">psd1_min</span><span class="p">)</span>

    <span class="n">psd2_min</span><span class="p">,</span> <span class="n">psd2_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psd2_clean</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psd2_clean</span><span class="p">)</span>
    <span class="n">psd2_clean</span> <span class="o">=</span> <span class="p">(</span><span class="n">psd2_clean</span> <span class="o">-</span> <span class="n">psd2_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">psd2_max</span> <span class="o">-</span> <span class="n">psd2_min</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Zxx1</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">signal1</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nperseg</span> <span class="o">/</span> <span class="n">smoothness</span><span class="p">),</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Zxx2</span> <span class="o">=</span> <span class="n">stft</span><span class="p">(</span><span class="n">signal2</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nperseg</span> <span class="o">/</span> <span class="n">smoothness</span><span class="p">),</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">)</span>

    <span class="n">dyad_similarities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)))</span>
    <span class="n">phase_coupling_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freqs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">freqs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;harmsim&quot;</span><span class="p">:</span>
                    <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dyad_similarity</span><span class="p">(</span><span class="n">f1</span> <span class="o">/</span> <span class="n">f2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">metric</span> <span class="o">==</span> <span class="s2">&quot;subharm_tension&quot;</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">subharm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_subharmonic_tension</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">],</span> <span class="n">n_harmonics</span><span class="o">=</span><span class="n">n_harms</span><span class="p">,</span> <span class="n">delta_lim</span><span class="o">=</span><span class="n">delta_lim</span><span class="p">,</span> <span class="n">min_notes</span><span class="o">=</span><span class="mi">2</span>
                    <span class="p">)</span>
                    <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">subharm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Compute the wPLI</span>
                <span class="n">cross_spectrum</span> <span class="o">=</span> <span class="n">Zxx1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Zxx2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">imaginary_cross_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cross_spectrum</span><span class="p">)</span>
                <span class="c1"># Add epsilon to the denominator</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">1e-10</span>
                <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">imaginary_cross_spectrum</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">imaginary_cross_spectrum</span><span class="p">))</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>

    <span class="n">harmonicity_values1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">harmonicity_values2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">harmonicity_values_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">phase_coupling_values1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">phase_coupling_values2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>
    <span class="n">phase_coupling_values_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">))</span>

    <span class="n">total_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psd1_clean</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psd2_clean</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)):</span>
        <span class="n">weighted_sum_harmonicity1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_harmonicity2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_harmonicity_all</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_phase_coupling1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_phase_coupling2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">weighted_sum_harmonicity1</span> <span class="o">+=</span> <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">weighted_sum_harmonicity2</span> <span class="o">+=</span> <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">weighted_sum_harmonicity_all</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="o">+</span> <span class="n">dyad_similarities</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">phase_mode</span> <span class="o">==</span> <span class="s2">&quot;weighted&quot;</span><span class="p">:</span>
                    <span class="n">weighted_sum_phase_coupling1</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">weighted_sum_phase_coupling2</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="o">+</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">psd1_clean</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">psd2_clean</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weighted_sum_phase_coupling1</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">weighted_sum_phase_coupling2</span> <span class="o">+=</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">phase_coupling_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">harmonicity_values1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_harmonicity1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">total_power</span><span class="p">)</span>
        <span class="n">harmonicity_values2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_harmonicity2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">total_power</span><span class="p">)</span>
        <span class="n">harmonicity_values_all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_harmonicity_all</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">total_power</span><span class="p">)</span>
        <span class="n">phase_coupling_values1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_phase_coupling1</span> <span class="o">/</span> <span class="n">count</span>
        <span class="n">phase_coupling_values2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_phase_coupling2</span> <span class="o">/</span> <span class="n">count</span>
        <span class="n">phase_coupling_values_all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weighted_sum_phase_coupling_all</span> <span class="o">/</span> <span class="n">count</span>

    <span class="n">harmonicity_values1</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">harmonicity_values1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span><span class="p">)</span>
    <span class="n">harmonicity_values2</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">harmonicity_values2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span><span class="p">)</span>
    <span class="n">harmonicity_values_all</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>
    <span class="n">phase_coupling_values1</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">phase_coupling_values1</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>
    <span class="n">phase_coupling_values2</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">phase_coupling_values2</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>
    <span class="n">phase_coupling_values_all</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
        <span class="n">phase_coupling_values_all</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothness_harm</span>
    <span class="p">)</span>

    <span class="c1"># Step 1: Calculate a combined metric for harmonicity and phase-coupling by multiplying normalized values</span>
    <span class="n">normalized_combined_metric</span> <span class="o">=</span> <span class="n">compute_resonance_values</span><span class="p">(</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span> <span class="n">phase_coupling_values_all</span>
    <span class="p">)</span>

    <span class="c1"># Find peaks in the spectra</span>
    <span class="n">harmonicity_peak_frequencies</span><span class="p">,</span> <span class="n">harm_peak_idx</span> <span class="o">=</span> <span class="n">find_spectral_peaks</span><span class="p">(</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">,</span> <span class="n">prominence_threshold</span><span class="o">=</span><span class="mf">0.1</span>
    <span class="p">)</span>
    <span class="n">phase_peak_frequencies</span><span class="p">,</span> <span class="n">phase_peak_idx</span> <span class="o">=</span> <span class="n">find_spectral_peaks</span><span class="p">(</span>
        <span class="n">phase_coupling_values_all</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">,</span> <span class="n">prominence_threshold</span><span class="o">=</span><span class="mf">0.0001</span>
    <span class="p">)</span>
    <span class="n">resonance_peak_frequencies</span><span class="p">,</span> <span class="n">res_peak_idx</span> <span class="o">=</span> <span class="n">find_spectral_peaks</span><span class="p">(</span>
        <span class="n">normalized_combined_metric</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">n_peaks</span><span class="p">,</span> <span class="n">prominence_threshold</span><span class="o">=</span><span class="mf">0.01</span>
    <span class="p">)</span>

    <span class="c1"># Compute spectral flatness and entropy values</span>
    <span class="n">harmonic_complexity</span> <span class="o">=</span> <span class="n">harmonic_entropy</span><span class="p">(</span>
        <span class="n">freqs</span><span class="p">,</span>
        <span class="n">harmonicity_values_all</span><span class="p">,</span>
        <span class="n">phase_coupling_values_all</span><span class="p">,</span>
        <span class="n">normalized_combined_metric</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># create dataframe with relevant values</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">&quot;harmonicity&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">harmonicity_values_all</span><span class="p">],</span>
            <span class="s2">&quot;phase_coupling&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">phase_coupling_values_all</span><span class="p">],</span>
            <span class="s2">&quot;resonance&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">normalized_combined_metric</span><span class="p">],</span>
            <span class="s2">&quot;harm_spectral_flatness&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Flatness&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harm_spectral_entropy&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Entropy&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harm_higuchi&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Higuchi Fractal Dimension&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harm_spectral_spread&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Spread&quot;</span><span class="p">][</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_spectral_flatness&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Flatness&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_spectral_entropy&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Entropy&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_higuchi&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Higuchi Fractal Dimension&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;phase_spectral_spread&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Spread&quot;</span><span class="p">][</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_spectral_flatness&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Flatness&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_spectral_entropy&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Entropy&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_higuchi&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Higuchi Fractal Dimension&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;res_spectral_spread&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="n">harmonic_complexity</span><span class="p">[</span><span class="s2">&quot;Spectral Spread&quot;</span><span class="p">][</span><span class="s2">&quot;Resonance&quot;</span><span class="p">]</span>
            <span class="p">],</span>
            <span class="s2">&quot;harmonicity_peak_frequencies&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">harmonicity_peak_frequencies</span><span class="p">],</span>
            <span class="s2">&quot;phase_peak_frequencies&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">phase_peak_frequencies</span><span class="p">],</span>
            <span class="s2">&quot;resonance_peak_frequencies&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">resonance_peak_frequencies</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_coupling_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_coupling&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_peaks_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

    <span class="c1"># save df</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">precision_hz</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;fmin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmin</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;fmax&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fmax</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_weighting&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_mode</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;smooth_fft&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothness</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;smooth_harm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothness_harm</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;fs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs</span>

    <span class="c1"># calculate harmonic similarity between peaks</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">peaks_to_harmsim</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harmonicity_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">peaks_to_harmsim</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;resonance_peak_frequencies&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">peaks_to_harmsim</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim_avg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_mean</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;harm_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_max</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;phase_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_max</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;res_harmsim&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">safe_max</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">plot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ax4</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd1</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkred&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Spectrum 1&quot;</span><span class="p">)</span>
        <span class="c1"># ax1.scatter(freqs[peaks_psd1], 10 * np.log10(psd1[peaks_psd1]), color=&#39;red&#39;, marker=&#39;o&#39;, s=50)  # Add red dots on detected peaks</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">psd2</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkgoldenrod&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Spectrum 2&quot;</span><span class="p">)</span>
        <span class="c1"># ax1.scatter(freqs[peaks_psd2], 10 * np.log10(psd2[peaks_psd2]), color=&#39;red&#39;, marker=&#39;o&#39;, s=50)  # Add red dots on detected peaks</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Spectra 1 and 2&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power (dB)&quot;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">harmonicity_values1</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;mediumaquamarine&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">harmonicity_values2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;turquoise&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">harmonicity_values_all</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cross Harmonic Spectrum&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">harm_peak_idx</span><span class="p">],</span>
            <span class="n">harmonicity_values_all</span><span class="p">[</span><span class="n">harm_peak_idx</span><span class="p">],</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Cross Harmonic and Phase Coupling Spectrum&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Harmonicity&quot;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">harmonicity_peak_frequencies</span><span class="p">:</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkblue&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

        <span class="n">ax3</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span> <span class="n">phase_coupling_values1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;violet&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">phase_coupling_values2</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;mediumorchid&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;dashed&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">,</span>
            <span class="n">phase_coupling_values_all</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;indigo&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Cross Phase Coupling Spectrum&quot;</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;solid&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">phase_peak_idx</span><span class="p">],</span>
            <span class="n">phase_coupling_values_all</span><span class="p">[</span><span class="n">phase_peak_idx</span><span class="p">],</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;indigo&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Phase Coupling&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">phase_peak_frequencies</span><span class="p">:</span>
            <span class="n">ax3</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkviolet&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

        <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">normalized_combined_metric</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;deeppink&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Resonance&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Resonance&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Frequency (Hz)&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Combined Metric&quot;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">res_peak_idx</span><span class="p">],</span>
            <span class="n">normalized_combined_metric</span><span class="p">[</span><span class="n">res_peak_idx</span><span class="p">],</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;deeppink&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># ax4.legend()</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">resonance_peak_frequencies</span><span class="p">:</span>
            <span class="n">ax4</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">peak</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

        <span class="c1"># Add the legend for the second y-axis (phase_coupling) plot</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
        <span class="n">lines2</span><span class="p">,</span> <span class="n">labels2</span> <span class="o">=</span> <span class="n">ax3</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span> <span class="o">+</span> <span class="n">lines2</span><span class="p">,</span> <span class="n">labels</span> <span class="o">+</span> <span class="n">labels2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;upper right&quot;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save_fig</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">savename</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">df</span></div>


<span class="sd">&quot;&quot;&quot;    def compute_harmonicity_metric_for_IMFs(data, sf, metric=&#39;harmsim&#39;, delta_lim=20, nIMFs=5, FREQ_BANDS=None):</span>
<span class="sd">        # Apply EMD to each channel</span>
<span class="sd">        emd_processor = EMD()</span>
<span class="sd">        IMFs = [emd_processor(channel)[:nIMFs] for channel in data]</span>

<span class="sd">        # Initialize variables</span>
<span class="sd">        list_idx = list(range(len(IMFs)))</span>
<span class="sd">        pairs = list(itertools.product(list_idx, list_idx))</span>
<span class="sd">        harm_conn_matrix = []</span>

<span class="sd">        if FREQ_BANDS is None:</span>
<span class="sd">            FREQ_BANDS = [</span>
<span class="sd">                [2, 3.55],</span>
<span class="sd">                [3.55, 7.15],</span>
<span class="sd">                [7.15, 14.3],</span>
<span class="sd">                [14.3, 28.55],</span>
<span class="sd">                [28.55, 49.4],</span>
<span class="sd">            ]</span>

<span class="sd">        if metric == &#39;wPLI_multiband&#39;:</span>
<span class="sd">            harm_conn_matrix = np.zeros((len(FREQ_BANDS), len(IMFs), len(IMFs)))</span>

<span class="sd">        # Compute the desired harmonicity metric for each corresponding IMF for each pair of channels</span>
<span class="sd">        for pair in pairs:</span>
<span class="sd">            imfs1 = IMFs[pair[0]]</span>
<span class="sd">            imfs2 = IMFs[pair[1]]</span>

<span class="sd">            for i in range(nIMFs):</span>
<span class="sd">                for j in range(nIMFs):</span>
<span class="sd">                    # Compute the desired harmonicity metric for the pair of IMFs</span>
<span class="sd">                    # [Replace this line with the appropriate code to compute the desired harmonicity metric for the pair of IMFs]</span>

<span class="sd">        # [Return the appropriate result]&quot;&quot;&quot;</span>
</pre></div>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Antoine Bellemare & Franois Lespinasse. This documentation is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> license.<br/>
  
      &copy; Copyright 20232023.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>